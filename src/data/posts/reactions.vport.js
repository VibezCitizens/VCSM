// src/data/posts/reactions.vport.js

import { supabase } from '@/lib/supabaseClient';

/* --------------------------------- helpers --------------------------------- */
const isSchemaCompatError = (e) => {
  const s = String(e?.code || e?.message || '').toLowerCase();
  // 42P01 undefined_table, 42703 undefined_column, 42P10 invalid_column_reference,
  // 23503 foreign_key_violation (e.g., actor FK), 0A000 not_supported
  return (
    s.includes('42p01') ||
    s.includes('42703') ||
    s.includes('42p10') ||
    s.includes('23503') ||
    s.includes('0a000')
  );
};

// Resolve actor_id: if acting as vport, map vportId → actor; else userId → actor.
async function resolveActorId({ userId, actorVportId }) {
  if (actorVportId) {
    const { data, error } = await supabase.rpc('actor_id_for_vport', { v_id: actorVportId });
    if (error) throw error;
    return data;
  }
  const { data, error } = await supabase.rpc('actor_id_for_user', { u_id: userId });
  if (error) throw error;
  return data;
}

// Normalize unified row to legacy vport shape:
// { id, post_id, user_id, reaction, created_at, as_vport, actor_vport_id }
function normalizeUnifiedRow(row) {
  const a = row.actors || row.actor || {};
  const isV = a.kind === 'vport';
  return {
    id: row.id,
    post_id: row.post_id,
    user_id: isV ? a.vport_id : a.profile_id, // legacy "user_id": vport_id when as_vport, else profile_id
    reaction: row.type,
    created_at: row.created_at,
    as_vport: isV,
    actor_vport_id: isV ? a.vport_id : null,
  };
}

/* ---------------------------------- SET ---------------------------------- */
/**
 * Upsert a reaction on a VPORT post.
 * If actorVportId is provided, we treat it as acting-as-vport; otherwise it's a plain user reaction.
 */
export async function setForVportPost({ postId, kind, userId, actorVportId }) {
  // Unified path
  try {
    if (!postId || !kind || !userId) throw new Error('setForVportPost: postId, kind, userId required');
    const actorId = await resolveActorId({ userId, actorVportId });

    // Ensure single choice: remove existing like/dislike by this actor on this post
    {
      const { error } = await supabase
        .from('post_reactions_unified')
        .delete()
        .eq('post_id', postId)
        .eq('actor_id', actorId)
        .in('type', ['like', 'dislike']);
      if (error) throw error;
    }

    // Upsert new reaction
    const { error: upErr } = await supabase
      .from('post_reactions_unified')
      .upsert(
        { post_id: postId, actor_id: actorId, type: kind },
        { onConflict: 'post_id,actor_id,type' }
      );
    if (upErr) throw upErr;

    // Return normalized row-like payload (matches list shape)
    return {
      id: null,
      post_id: postId,
      user_id: actorVportId ? actorVportId : userId,
      reaction: kind,
      created_at: new Date().toISOString(),
      as_vport: !!actorVportId,
      actor_vport_id: actorVportId ?? null,
    };
  } catch (e) {
    if (!isSchemaCompatError(e)) throw e;

    // Legacy fallback: vport_post_reactions with actor_key generated by DB
    const as_vport = !!actorVportId;

    const { data, error } = await supabase
      .from('vport_post_reactions')
      .upsert(
        [
          {
            post_id: postId,
            user_id: userId, // auth.uid()
            reaction: kind,  // 'like' | 'dislike'
            as_vport,
            actor_vport_id: as_vport ? actorVportId : null,
            // actor_key generated in DB (computed from as_vport/actor_vport_id)
          },
        ],
        { onConflict: 'post_id,user_id,actor_key' }
      )
      .select('*')
      .single();

    if (error) throw error;
    return data;
  }
}

/* ---------------------------------- LIST ---------------------------------- */
/**
 * List all reactions for a VPORT post.
 * Normalized to: { id, post_id, user_id, reaction, created_at, as_vport, actor_vport_id }
 */
export async function listForVportPost({ postId }) {
  // Unified path
  try {
    const { data, error } = await supabase
      .from('post_reactions_unified')
      .select(`
        id,
        post_id,
        type,
        created_at,
        actors:actors!post_reactions_unified_actor_id_fkey (
          id,
          kind,
          profile_id,
          vport_id
        )
      `)
      .eq('post_id', postId)
      .order('created_at', { ascending: true });

    if (error) throw error;
    return (data ?? []).map(normalizeUnifiedRow);
  } catch (e) {
    if (!isSchemaCompatError(e)) throw e;

    // Legacy fallback
    const { data, error } = await supabase
      .from('vport_post_reactions')
      .select('id,post_id,user_id,reaction,created_at,as_vport,actor_vport_id')
      .eq('post_id', postId)
      .order('created_at', { ascending: true });

    if (error) throw error;
    return data ?? [];
  }
}

/* --------------------------------- CLEAR --------------------------------- */
/**
 * Clear the caller’s reaction on a VPORT post.
 */
export async function clearForVportPost({ postId, userId, actorVportId }) {
  // Unified path
  try {
    if (!postId || !userId) throw new Error('clearForVportPost: postId,userId required');
    const actorId = await resolveActorId({ userId, actorVportId });

    const { error } = await supabase
      .from('post_reactions_unified')
      .delete()
      .eq('post_id', postId)
      .eq('actor_id', actorId)
      .in('type', ['like', 'dislike']); // remove both for safety

    if (error) throw error;
    return true;
  } catch (e) {
    if (!isSchemaCompatError(e)) throw e;

    // Legacy fallback
    const as_vport = !!actorVportId;

    let q = supabase
      .from('vport_post_reactions')
      .delete()
      .eq('post_id', postId)
      .eq('user_id', userId);

    q = as_vport
      ? q.eq('as_vport', true).eq('actor_vport_id', actorVportId)
      : q.eq('as_vport', false).is('actor_vport_id', null);

    const { error } = await q;
    if (error) throw error;
    return true;
  }
}
